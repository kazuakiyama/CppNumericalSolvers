// -*-c++-*-
// This file is part of Eigen, a lightweight C++ template library
// for linear algebra.
//
// Copyright (C) 2015 Michael Tesch tesch a tum de
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
//
#ifndef EIGEN_MATIO_MODULE
#define EIGEN_MATIO_MODULE

#include "matio.h"

namespace Eigen {

namespace internal {
// defaults
template <typename Tp> struct matio_type;
template <typename Tp> struct matio_class;
template <typename Tp> struct matio_flag { static const matio_flags id = (matio_flags)0; };
// specializations
template <> struct matio_type<float> { typedef float type; static const matio_types id = MAT_T_SINGLE; };
template <> struct matio_type<double> { typedef double type; static const matio_types id = MAT_T_DOUBLE; };
template <> struct matio_type<long double> { typedef double type; static const matio_types id = MAT_T_DOUBLE; };
template <typename Tp> struct matio_type<std::complex<Tp> > { typedef Tp type; static const matio_types id = matio_type<Tp>::id; };
template <> struct matio_class<float> { static const matio_classes id = MAT_C_SINGLE; };
template <> struct matio_class<double> { static const matio_classes id = MAT_C_DOUBLE; };
template <> struct matio_class<long double> { static const matio_classes id = MAT_C_DOUBLE; };
template <typename Tp> struct matio_flag<std::complex<Tp> > { static const matio_flags id = MAT_F_COMPLEX; };

}

class MatioFile {
public:
  MatioFile() : _file(NULL) {}
  MatioFile(const char * filename,
            int mode = MAT_ACC_RDWR,
            bool create = true,
            const char * header = "MatioFile")
    : _file(NULL)
  {
    open(filename, mode, create, header);
  }
  ~MatioFile()
  {
    Mat_Close(_file);
  }
  mat_t * file() { return _file; }
  bool open(const char * filename,
            int mode = MAT_ACC_RDWR,
            bool create = true,
            const char * header = "MatioFile")
  {
    if (_file)
      close();
    _file = Mat_Open(filename, mode);
    if (_file == NULL && create)
      _file = Mat_CreateVer(filename, header, MAT_FT_DEFAULT);
    if (NULL == _file) {
      std::cout << "MatioFile() unable to open " << filename << "\n";
      return false;
    }
    return true;
  }

  void close()
  {
    if (_file)
      Mat_Close(_file);
    _file = NULL;
  }

  template <class Matrix>
  bool
  write_mat(const char * matname, const Matrix & matrix)
  {
    if (!_file || !matname)
      return false;
    typedef typename internal::matio_type<typename Matrix:: Scalar>::type mat_type;
#if MATIO_VERSION >= 150
    enum matio_compression compression = MAT_COMPRESSION_NONE;
#else
    // version 134
    enum matio_compression compression = COMPRESSION_NONE;
#endif
    matvar_t * var;
    int status;
#if MATIO_VERSION >= 150
    size_t rows = matrix.rows();
    size_t cols = matrix.cols();
    size_t dims[2] = {rows, cols};
#else
    int rows = matrix.rows();
    int cols = matrix.cols();
    int dims[2] = {rows, cols};
#endif

    enum matio_types typei = internal::matio_type<typename Matrix:: Scalar>::id;
    matio_classes classid = internal::matio_class<typename Matrix:: Scalar>::id;
    matio_flags cxflag = internal::matio_flag<typename Matrix:: Scalar>::id;

    // todo - specialize this for the (common) case where mat_type is the same as
    // Matrix::Scalar AND Scalar is NOT complex, in which case we dont need to create
    // temp matrices here...
    void * data;
    Eigen::Matrix<mat_type,Eigen::Dynamic,Eigen::Dynamic> dst_re(rows, cols);
    Eigen::Matrix<mat_type,Eigen::Dynamic,Eigen::Dynamic> dst_im(rows, cols);
#if MATIO_VERSION >= 150
    mat_complex_split_t cs;
#else
    ComplexSplit cs;
#endif

    if (cxflag == MAT_F_COMPLEX) {
      dst_re = matrix.real().template cast<mat_type>();
      dst_im = matrix.imag().template cast<mat_type>();
      data = &cs;
      cs.Re = dst_re.data();
      cs.Im = dst_im.data();
    }
    else {
      dst_re = matrix.real().template cast<mat_type>();
      data = dst_re.data();
    }

    var = Mat_VarCreate(matname, classid, typei, 2, dims, data, cxflag);
    if (NULL == var) {
      std::cout << "write_mat() unable to create matrix\n";
      return false;
    }

    // todo - thread safety
    status = Mat_VarWrite(_file, var, compression);
    if (status) {
      std::cout << "write_mat() unable to put variable\n";
    }

    Mat_VarFree(var);
    return status == 0;
  }

private:
  mat_t * _file;
};

template <class Matrix>
bool
write_mat(const char * filename, const char * matname, const Matrix & matrix)
{
  MatioFile file(filename);
  if (!file.file())
    return false;
  return file.write_mat(matname, matrix);
}

template <class Matrix>
void read_mat(const char * filename, const char * matname, Matrix & matrix)
{
  MatioFile file(filename, MAT_ACC_RDONLY, false);
  throw std::exception();
}

}

#endif
