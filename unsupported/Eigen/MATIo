// -*-c++-*-
// This file is part of Eigen, a lightweight C++ template library
// for linear algebra.
//
// Copyright (C) 2015 Michael Tesch tesch a tum de
//
// This Source Code Form is subject to the terms of the Mozilla
// Public License v. 2.0. If a copy of the MPL was not distributed
// with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
//
#ifndef EIGEN_MATIO_MODULE
#define EIGEN_MATIO_MODULE

#include "matio.h"

namespace Eigen {

namespace internal {

template <typename Tp> struct matio_type;
template <typename Tp> struct matio_class;
template <> struct matio_type<double> { typedef double type; static const matio_types id = MAT_T_DOUBLE; };
template <> struct matio_class<double> { static const matio_classes id = MAT_C_DOUBLE; }; 
template <typename Tp> struct matio_flag { static const matio_flags id = (matio_flags)0; };
template <typename Tp> struct matio_flag<std::complex<Tp> > { static const matio_flags id = MAT_F_COMPLEX; }; 

}

template <class Matrix>
bool
write_mat(const char * filename, const char * matname, const Matrix & matrix)
{
  typedef typename internal::matio_type<typename Matrix:: Scalar>::type mat_type;
#if MATIO_VERSION >= 150
  enum matio_compression compression = MAT_COMPRESSION_NONE;
#else
  // version 134
  enum matio_compression compression = COMPRESSION_NONE;
#endif
  mat_t * file;
  matvar_t * var;
  int status;
#if MATIO_VERSION >= 150
  size_t rows = matrix.rows();
  size_t cols = matrix.cols();
  size_t dims[2] = {rows, cols};
#else
  int rows = matrix.rows();
  int cols = matrix.cols();
  int dims[2] = {rows, cols};
#endif

  enum matio_types typei = internal::matio_type<typename Matrix:: Scalar>::id;
  matio_classes classid = internal::matio_class<typename Matrix:: Scalar>::id;
  matio_flags cxflag = internal::matio_flag<typename Matrix:: Scalar>::id;

  file = Mat_CreateVer(filename, "tesch", MAT_FT_DEFAULT);
//file = Mat_Open(filename, MAT_ACC_RDWR);
  if (NULL == file) {
    std::cout << "write_mat() unable to open " << filename << "\n";
    return false;
  }

  void * data;
  Eigen::Matrix<mat_type,Eigen::Dynamic,Eigen::Dynamic> dst_re(rows, cols);
  Eigen::Matrix<mat_type,Eigen::Dynamic,Eigen::Dynamic> dst_im(rows, cols);
#if MATIO_VERSION >= 150
  mat_complex_split_t cs;
#else
  ComplexSplit cs;
#endif

  if (cxflag == MAT_F_COMPLEX) {
    dst_re = matrix.real().template cast<mat_type>();
    dst_im = matrix.imag().template cast<mat_type>();
    data = &cs;
    cs.Re = dst_re.data();
    cs.Im = dst_im.data();
  }
  else {
    dst_re = matrix.real().template cast<mat_type>();
    data = dst_re.data();
  }

  var = Mat_VarCreate(matname, classid, typei, 2, dims, data, cxflag);
  if (NULL == var) {
    Mat_Close(file);
    std::cout << "write_mat() unable to create matrix\n";
    return false;
  }

  if (!var->data) {
    std::cout << "BAD\n";
    return 0;
  }

  status = Mat_VarWrite(file, var, compression);
  if (status) {
    std::cout << "write_mat() unable to put variable\n";
  }

  Mat_VarFree(var);
  Mat_Close(file);
  return status == 0;
}

template <class Matrix>
void read_mat(const char * filename, const char * matname, Matrix & matrix)
{
  throw std::exception();
}
}

#endif
